# templates/auto-gitlab/template.yml
spec:
  inputs:
    job-prefix:
      description: "Job prefix"
      type: string
      default: "-$CI_PROJECT_ID-$CI_COMMIT_SHORT_SHA"
      
    auto-rebase:
      description: "Auto rebase source branch"
      type: boolean
      default: false
      
    auto-approve:
      description: "Auto approve merge request"
      type: boolean
      default: false
    
    auto-merge:
      description: "Auto confirm merge request"
      type: boolean
      default: false
    auto-remove-source-branch:
      description: "Auto remove source branch after merge"
      type: boolean
      default: false
      
    auto-tag:
      description: "Create auto TAG."
      type: boolean
      default: false
    auto-tag-pattern:
      description: "Validate TAG by pattern" # "/^[vV]?\\d\\.\\d+\\.\\d+$/" или /^[vV]?\d\.\d+\.\d+$/
      type: string
      default: /^[vV]?\d\.\d+\.\d+$/
    auto-tag-version-prefix:
      description: "Prefix for autogenerated tag"
      type: string
      default: ""
    auto-tag-version-major:
      type: string
      default: "0"
    auto-tag-version-minor:
      type: string
      default: "0"      
      
    auto-release:
      description: "Auto release after merge"
      type: boolean
      default: false
#    artifacts-dir:
#      description: "Directory with artifacts"
#      type: string
#      default: "artifacts-$CI_PROJECT_ID-$CI_COMMIT_SHORT_SHA"
    
---

include:
  - component: $CI_SERVER_FQDN/library/cicd/utils/utils@~latest

variables: 
  AUTO_REMOVE_SOURCE_BRANCH: $[[ inputs.auto-remove-source-branch ]]
  CI_COMMIT_TAG_PATTERN: $[[ inputs.auto-tag-pattern ]]
  AUTO_TAG_VERSION_PREFIX: $[[ inputs.auto-tag-version-prefix ]]
  AUTO_TAG_VERSION_MAJOR: $[[ inputs.auto-tag-version-major ]]
  AUTO_TAG_VERSION_MINOR: $[[ inputs.auto-tag-version-minor ]]

stages:
  - auto-merge
  - auto-tag
  - auto-release

.auto-rebase-needs: 
  -

.auto-approve-needs:
  -

.auto-merge-needs:
  -

.auto-create-TAG-needs:
  -

.auto-release-needs:
  -

.release-artefacts:
  - ""

.auto-rebase-rules-extends:
  - when: on_success

.auto-approve-rules-extends:
  - when: on_success 

.auto-merge-rules-extends:
  - when: on_success
  
.auto-create-TAG-rules-extends:
  - !reference [ .default-branch, only ]
  - when: on_success
  
.auto-release-rules-extends:
  - when: on_success

.gitlab-api-rebase: |
  rebase_merge_request() {
      local token="${1:?Не передан токен авторизации}"
      local iid="${2:?Не передан IID merge request}"
      local timeout="${3:-60}"   # максимальное время ожидания в секундах
      local interval=5            # интервал между проверками

      # Проверка обязательных переменных CI
      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"

      REBASE_JSON=$(jq -n \
          '{
            "skip_ci": true
          }'
      )

      local api_url="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}/rebase"

      # Запускаем rebase
      log_info "Запуск rebase для MR IID=${iid}..."
      rebase_info=$(curl -f -X PUT \
          -H "Authorization: Bearer ${token}" \
          -H "Content-Type: application/json" \
          -d "${REBASE_JSON}" \
          "${api_url}" || fail "Не удалось запустить rebase для MR IID=${iid}")

      log_info "$rebase_info"
  
      log_info "Rebase запущен, ожидаем завершения..."

      local elapsed=0
      while [ "$elapsed" -lt "$timeout" ]; do
          local local_result
          local in_progress
          local merge_error

          local_result=$(curl -s -X GET \
            -H "Authorization: Bearer ${token}" \
            --data-urlencode "include_rebase_in_progress=true" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}")

          log_info "$local_result"

          in_progress=$(echo "$local_result" | jq -r '.rebase_in_progress')
          merge_error=$(echo "$local_result" | jq -r '.merge_error')

          if [[ "$in_progress" == "false" ]]; then
              if [[ "$merge_error" != "null" ]]; then
                  fail "Rebase для MR IID=${iid} завершился с ошибкой: $merge_error"
              else
                  log_info "Rebase для MR IID=${iid} завершен успешно."
                  return 0
              fi
          fi

          sleep $interval
          elapsed=$((elapsed + interval))
      done

      fail "Rebase для MR IID=${iid} не завершился за ${timeout} секунд."
  }
  
.gitlab-api-merge: |
  get_open_merge_requests() {
      local token="${1:?Не передан токен авторизации}"

      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
      : "${CI_COMMIT_REF_NAME:?Не задана переменная CI_COMMIT_REF_NAME}"

      mr_list=$(curl -s -f -X GET \
        -H "Authorization: Bearer ${token}" \
        --data-urlencode "state=opened" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests")
  
      filtered_mr=$(echo "$mr_list" | jq --arg branch "$CI_COMMIT_REF_NAME" '[.[] | select(.source_branch==$branch)]')

      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" ]; then
        filtered_mr=$(echo "$filtered_mr" | jq --arg target "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" '[.[] | select(.target_branch==$target)]')
      fi

      echo "$filtered_mr"
  }

  create_merge_request() {
    local token="${1:?Не передан токен авторизации}"
    local target_branch="${2:-$CI_DEFAULT_BRANCH}"
    local title="${3:-Автоматический merge request от CI}"
  
    # Проверка обязательных переменных CI
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
    : "${CI_COMMIT_REF_NAME:?Не задана переменная CI_COMMIT_REF_NAME}"
    : "${target_branch:?Не задана целевая ветка и CI_DEFAULT_BRANCH пуст}"
  
    CREATE_MERGE_JSON=$(jq -n \
        --arg source_branch "${CI_COMMIT_REF_NAME}" \
        --arg target_branch "${target_branch}" \
        --arg title "${title}" \
        '{source_branch: $source_branch, target_branch: $target_branch, squash: true, title: $title }'
    )
  
    # Выполним запрос на создание MR
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_MERGE_JSON}" \
      "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
  }

  merge_merge_request() {
      token="$1"
      iid="$2"
  
      if [ -z "$token" ]; then
          log_info "Не передан токен авторизации" >&2
          return 1
      fi
      if [ -z "$iid" ]; then
          log_info "Не передан ID Merge Request" >&2
          return 1
      fi
  
      if [ -z "$CI_API_V4_URL" ]; then
          log_info "Не задана переменная CI_API_V4_URL" >&2
          return 1
      fi
      if [ -z "$CI_PROJECT_ID" ]; then
          log_info "Не задана переменная CI_PROJECT_ID" >&2
          return 1
      fi
      if [ -z "$CI_COMMIT_MESSAGE" ]; then
          log_info "Не задана переменная CI_COMMIT_MESSAGE" >&2
          return 1
      fi
  
      # Получаем информацию о текущем MR
      MR_info=$(curl -s -f -X GET \
          -H "Authorization: Bearer $token" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid") || return 1
  
      log_info "$MR_info"
  
      remove_branch="$AUTO_REMOVE_SOURCE_BRANCH"
  
      if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_PROTECTED" = "true" ]; then
          log_info "Ветка защищена, принудительно отключаем удаление после merge"
          remove_branch="false"
      fi
  
      merge_status=$(echo "$MR_info" | jq -r '.merge_status')
  
      # Определяем, нужен ли auto_merge
      auto_merge_json=""
      if [ "$merge_status" = "checking" ]; then
          auto_merge_json=", \"auto_merge\": true"
      fi
  
      MERGE_MERGE_JSON=$(jq -n \
          --arg remove_branch "$remove_branch" \
          --arg auto_merge_strategy "merge_when_pipeline_succeeds" \
          --arg squash_commit_message "$CI_COMMIT_MESSAGE" \
          '{
            should_remove_source_branch: ($remove_branch == "true"), 
            auto_merge_strategy: $auto_merge_strategy, 
            squash: true, 
            squash_commit_message: $squash_commit_message
          }')
  
      if [ -n "$auto_merge_json" ]; then
          MERGE_MERGE_JSON=$(echo "$MERGE_MERGE_JSON" | jq '. + {auto_merge: true}')
      fi
  
      # Первый merge
      if ! curl -f -X PUT \
          -H "Authorization: Bearer $token" \
          -H "Content-Type: application/json" \
          -d "$MERGE_MERGE_JSON" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"; then
  
          log_info "Первый merge не удался, пробуем повторно без auto_merge"
  
          # Убираем auto_merge
          MERGE_MERGE_JSON_NO_AUTO=$(echo "$MERGE_MERGE_JSON" | jq 'del(.auto_merge)')
  
          curl -f -X PUT \
            -H "Authorization: Bearer $token" \
            -H "Content-Type: application/json" \
            -d "$MERGE_MERGE_JSON_NO_AUTO" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"
      fi
  }

.gitlab-api-approve: |
  approve_merge_request() {
      local token="${1:?Не передан токен авторизации}"
      local iid="${2:?Не передан IID merge request}"

      # Проверка обязательных переменных CI
      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"

      # Выполним запрос на approve MR
      curl -X POST \
        -H "Authorization: Bearer ${token}" \
        "${CI_API_V4_URL}/projects/$CI_PROJECT_ID/merge_requests/$iid/approve"
  }

.gitlab-api-tags: |
  api_get_tags() {
    local token="${1:?Не передан токен авторизации}"
    local search="${2:-}"  # Можно передавать фильтр
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
  
    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"
  
    tag_list=$(curl -s -f -X GET \
      -H "Authorization: Bearer ${token}" \
      --data-urlencode "order_by=version" \
      --data-urlencode "sort=desc" \
      $( [ -n "$search" ] && echo "--data-urlencode search=$search" ) \
      "$api_url")
    
    echo "$tag_list"
  }
  
  get_last_release_tag() {
    local tags_json="${1:-[]}"
    echo "$tags_json" | jq -r 'if type=="array" and length>0 then .[0] else empty end'
  }
  
  get_patch_from_tag() {
    local tag="$1"
    
    # Убираем "v" в начале, если есть
    tag="${tag#v}"
    
    # Разбиваем на части
    set -- $(echo "$tag" | tr '.' ' ')
    local major="$1"
    local minor="$2"
    local patch="$3"
    
    # Проверяем, что patch — число
    case "$patch" in
      ''|*[!0-9]*) patch=0 ;;
    esac
    
    echo "$patch"
  }

  create_next_tag() {
    local token="${1:?Не передан токен авторизации}"
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
    : "${CI_DEFAULT_BRANCH:?Не задана переменная CI_DEFAULT_BRANCH}"
  
    # Получаем теги с нужным мажором и минором, отсортированные по версии (desc)
    TAGS_JSON=$(api_get_tags "$token" "${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}." | tr -d '\r' )
    
    printf '%s\n' "$TAGS_JSON" | jq .
    
    LAST_TAG=$(get_last_release_tag "$TAGS_JSON")

    log_info "$LAST_TAG" 
  
    if [ -z "$LAST_TAG" ]; then
      patch=0
      ref="$CI_DEFAULT_BRANCH"
    else
      patch=$(get_patch_from_tag "$(echo "$LAST_TAG" | jq -r '.name')")
      patch=$((patch + 1))
      ref="$CI_COMMIT_SHA"
    fi

    # Формируем имя нового тега
    new_tag="${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}.${patch}"
    log_info "Создаем тег: $new_tag (ref: $ref)"

    CREATE_TAG_JSON=$(jq -n \
      --arg tag_name "$new_tag" \
      --arg _ref "$ref" \
      '{ tag_name: $tag_name, ref: $_ref }'
    )

    log_info "$CREATE_TAG_JSON"
  
    # Создаем тег через API
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_TAG_JSON}" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"  
  }


.json-grabber: |
  generate_json() {
    local prefix="$1"
    asset_json="[]"
    tmp_json=$(mktemp)
  
    # ищем переменные с заданным префиксом
    for asset_var in $(env | awk -F= -v pfx="$prefix" '$1 ~ "^"pfx {print $1}'); do
      asset_value=$(printenv "$asset_var")
      if [ -n "$asset_value" ]; then
        # декодируем base64 и записываем в tmp
        echo "$asset_value" | base64 -d >> "$tmp_json"
      fi
    done
  
    if [ -s "$tmp_json" ]; then
      # собираем все JSON элементы в массив
      asset_json=$(jq -s '.' "$tmp_json")
    fi
  
    rm -f "$tmp_json"
    echo "$asset_json"
  }

.release-description: |
  generate_release_description() {
    local desc_file="$1"
    local notes_json="$2"
  
    # --- 1) Постоянная часть ---
    echo "Автоматический релиз для $CI_COMMIT_TAG" > "$desc_file"
    echo "[Последний релиз](${CI_PROJECT_URL}/-/releases/permalink/latest)" >> "$desc_file"
  
    # --- 2) Release notes (если есть) ---
    if [ -n "$notes_json" ] && echo "$notes_json" | jq -e 'length > 0' > /dev/null; then
      echo "" >> "$desc_file"
      echo "---" >> "$desc_file"
      echo "### Container registry:" >> "$desc_file"
  
      # notes_json уже массив объектов JSON
      echo "$notes_json" | jq -c '.[]' | while read -r note_value; do
        echo "$note_value" | jq -r '.head // empty' >> "$desc_file"
        echo "$note_value" | jq -r '.image // empty' >> "$desc_file"
        echo "$note_value" | jq -r '.latest // empty' >> "$desc_file"
      done
    fi
  
  }

"auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends:
    - .package-cache
  needs:
    - !reference [ .auto-rebase-needs ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-rebase ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          rebase_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [ .tagged, not ]
    - !reference [ .source, only_merge ]    
    - if: '"$[[ inputs.auto-rebase ]]" == "true"'
      when: never
    - !reference [ .auto-rebase-rules-extends ]
    - when: on_success

"auto-approve$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: 
   - .package-cache
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - !reference [ .auto-approve-needs ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-approve ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          approve_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [ .tagged, not ]
    - !reference [ .source, only_merge ]    
    - if: '"$[[ inputs.auto-approve ]]" == "true"'
      when: never
    - !reference [ .auto-approve-rules-extends ]
    - when: on_success

"auto-merge$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  retry: 
    max: 2
    when: script_failure
  extends:
    - .package-cache
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - job: "auto-approve$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - !reference [ .auto-merge-needs ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          merge_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [ .tagged, not ]
    - !reference [ .source, only_merge ]    
    - if: '"$[[ inputs.auto-merge ]]" != "true"'
      when: never
    - !reference [ .auto-merge-rules-extends ]
    - when: on_success

"auto-create-TAG$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-tag
  extends:
    - .package-cache
  needs:
    - !reference [ .auto-create-TAG-needs ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-tags ]
  script:
    - create_next_tag "$AUTO_GITLAB_TOKEN"
  rules:
    - !reference [ .tagged, not ]
    - if: '"$[[ inputs.auto-tag ]]" != "true"'
      when: never
    - !reference [ .auto-create-TAG-rules-extends ]
    - when: on_success

"auto-release$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-release
  image: registry.gitlab.com/gitlab-org/cli:latest
  extends:
    - .package-cache
  needs:
    - !reference [ .auto-release-needs ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .json-grabber ]
    - !reference [ .release-description ]
  script:
    - |
      DESC_FILE="desc.md"
      NOTES_JSON=$(generate_json release_notes_)

      ASSETS_JSON=$(generate_json release_asset_)

      generate_release_description "$DESC_FILE" "$NOTES_JSON"
      log_info "DESC_FILE: $(cat $DESC_FILE)"

      glab auth login --hostname $CI_SERVER_HOST --job-token $CI_JOB_TOKEN
      
      log_info "Login success."
      
      set -- "--name" "Release $CI_COMMIT_TAG" "-F" "$DESC_FILE" "--ref" "$CI_COMMIT_SHA"
      
      if echo "$ASSETS_JSON" | jq -e 'length > 0' > /dev/null; then
        assets_json_obj=$(echo "$ASSETS_JSON" | jq -c '.')
        log_info "$assets_json_obj"
        set -- "$@" --assets-links "$assets_json_obj"
      fi
     
      log_info "call: glab release create $*"

      glab release create "$CI_COMMIT_TAG" "$@"
      
      log_info "Release created successful."

  artifacts:
    paths:
      !reference [ .release-artefacts ]
    when: on_success

  rules:
    - !reference [ .tagged, only ]
    - if: '"$[[ inputs.auto-release ]]" != "true"'
      when: never
    - !reference [ .auto-release-rules-extends ]
    - when: on_success



#
#      fi
#      glab release upload "$TAG" --assets-links="[$(echo "$release_asset_file" | base64 -d)]"
#
#      if [ -n "$CI_COMMIT_TAG" ]; then
#      glab release upload "latest" --assets-links="[$(echo "release_asset_file_latest" | base64 -d)]"
#      else
#      log_info "CI_COMMIT_TAG пустой — пропускаем upload"
#      fi